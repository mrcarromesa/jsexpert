!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
Gaussian	lib/gaussian.js	/^class Gaussian {$/;"	C
GenerateData	test/tool_generate_data.py	/^class GenerateData:$/;"	c
HMM	lib/hmm.js	/^class HMM {$/;"	C
HMM	test/hmm.py	/^class HMM(object):$/;"	c
Initialize	lib/initialize.js	/^class Initialize {$/;"	C
JSONFILES	Makefile	/^JSONFILES=test\/expectation.json test\/initialize.json test\/gaussian.json \\$/;"	m
Sigma	test/initialize.py	/^Sigma = Sigma[reorder_indices, :, :]$/;"	v
Sigma	test/initialize.py	/^Sigma = np.stack([$/;"	v
SigmaList	lib/initialize.js	/^      const SigmaList = [];$/;"	A
SigmaSorted	test/fit.test.js	/^  const SigmaSorted = [];$/;"	A
SigmaSorted	test/initialize.test.js	/^  const SigmaSorted = [];$/;"	A
SigmaSorted	test/sample.test.js	/^  const SigmaSorted = [];$/;"	A
TODO	lib/hmm.js	/^    \/\/ TODO: Unsure why reference, has no normalization of pi$/;"	T
__init__	test/hmm.py	/^    def __init__(self, num_states, data_dim, obs=None, time=None):$/;"	m	class:HMM
__init__	test/tool_generate_data.py	/^    def __init__(self,$/;"	m	class:GenerateData
_backward	test/hmm.py	/^    def _backward(self):$/;"	m	class:HMM
_backward_step	test/hmm.py	/^    def _backward_step(self, n, betta, b_p):$/;"	m	class:HMM
_create_the_computational_graph	test/hmm.py	/^    def _create_the_computational_graph(self):$/;"	m	class:HMM
_emission_probs_family	test/hmm.py	/^    def _emission_probs_family(self):$/;"	m	class:HMM
_emissions_eval	test/hmm.py	/^    def _emissions_eval(self):$/;"	m	class:HMM
_expectation	test/hmm.py	/^    def _expectation(self):$/;"	m	class:HMM
_forward	test/hmm.py	/^    def _forward(self):$/;"	m	class:HMM
_forward_step	test/hmm.py	/^    def _forward_step(self, n, alpha, c):$/;"	m	class:HMM
_init_p0_tp	test/hmm.py	/^    def _init_p0_tp(self):$/;"	m	class:HMM
_maximization	test/hmm.py	/^    def _maximization(self):$/;"	m	class:HMM
_simulate	test/hmm.py	/^    def _simulate(self):$/;"	m	class:HMM
_simulate_step	test/hmm.py	/^    def _simulate_step(self, n, states, samples):$/;"	m	class:HMM
_viterbi	test/hmm.py	/^    def _viterbi(self):$/;"	m	class:HMM
_viterbi_step	test/hmm.py	/^    def _viterbi_step(self, n, w, am):$/;"	m	class:HMM
_xi_calc	test/hmm.py	/^    def _xi_calc(self, n, xi):$/;"	m	class:HMM
allcloseWrapper	test/allclose.js	/^function allcloseWrapper (t, a, b, { rtol = 1e-05, atol = 1e-08 } = {}) {$/;"	F
alpha_hat_list	lib/hmm.js	/^    const alpha_hat_list = [alpha_hat_0]; \/\/ [(N, S)]$/;"	A
argmax_w_list	lib/hmm.js	/^    const argmax_w_list = [tf.zeros(w_0.shape, 'int32')];$/;"	A
beta_list	lib/hmm.js	/^    const beta_list = [beta_T]; \/\/ [(N, S)]$/;"	A
c_list	lib/hmm.js	/^    const c_list = [c_0]; \/\/ [(N,)]$/;"	A
config	test/tool_generate_data.py	/^    def config(self):$/;"	m	class:GenerateData
converged	lib/hmm.js	/^      converged: converged,$/;"	P
covariance_matrix	test/gaussian.py	/^    covariance_matrix=tf.constant(generator.Sigma)$/;"	v
covariance_type	test/fit.py	/^    covariance_type="full"$/;"	v
covariance_type	test/inference.py	/^    covariance_type="full"$/;"	v
data	lib/initialize.js	/^  const data = new Float32Array(dimensions * dimensions);$/;"	V
data	test/tool_generate_data.py	/^    def data(self):$/;"	m	class:GenerateData
data_tf	test/gaussian.py	/^data_tf = tf.constant(emissions)$/;"	v
diagonalTensor	lib/initialize.js	/^function diagonalTensor (value, dimensions) {$/;"	F
dimensions	test/initialize.test.js	/^    dimensions: 1$/;"	P
dimensions	test/usage.test.js	/^      dimensions: 2$/;"	P
dimensions	test/usage.test.js	/^    dimensions: dimensions$/;"	P
distributions	test/gaussian.py	/^distributions = tfp.distributions.MultivariateNormalFullCovariance($/;"	v
emissions_collaped	test/fit.py	/^emissions_collaped = emissions_collaped.reshape($/;"	v
emissions_collaped	test/fit.py	/^emissions_collaped = np.transpose(emissions, [1, 0, 2])  # (N, T, D)$/;"	v
emissions_collaped	test/inference.py	/^emissions_collaped = emissions_collaped.reshape($/;"	v
emissions_collaped	test/inference.py	/^emissions_collaped = np.transpose(emissions, [1, 0, 2])  # (N, T, D)$/;"	v
emissions_list	lib/hmm.js	/^      const emissions_list = [emissions_0];$/;"	A
emissions_pdf	test/gaussian.py	/^emissions_pdf = distributions.prob(tf.expand_dims(data_tf, -2))$/;"	v
emissions_timeless	test/initialize.py	/^emissions_timeless = emissions.reshape($/;"	v
exit	index.js	/^function exit(condition) {$/;"	F
fit	test/hmm.py	/^    def fit(self, data, max_steps=100, TOL=0.0001):$/;"	m	class:HMM
gaussian	test/gaussian.test.js	/^  const gaussian = tf.tidy(() => new Gaussian({$/;"	F
generate	test/hmm.py	/^    def generate(self, num_samples):$/;"	m	class:HMM
generator	test/expectation.py	/^generator = GenerateData(num_time=2, seed=2)$/;"	v
generator	test/fit.py	/^generator = GenerateData(num_obs=20)$/;"	v
generator	test/gaussian.py	/^generator = GenerateData()$/;"	v
generator	test/inference.py	/^generator = GenerateData(num_time=7, seed=2)$/;"	v
generator	test/initialize.py	/^generator = GenerateData(seed=2)$/;"	v
generator	test/log_likelihood.py	/^generator = GenerateData(num_time=7)$/;"	v
generator	test/maximization.py	/^generator = GenerateData(num_time=7, seed=2)$/;"	v
generator	test/sample.py	/^generator = GenerateData(num_obs=181, num_time=21, seed=2)$/;"	v
groups	lib/initialize.js	/^    const groups = [];$/;"	A
hmm	test/expectation.py	/^hmm = HMM(generator.num_states, generator.num_dims,$/;"	v
hmm	test/expectation.test.js	/^  const hmm = new HMM({$/;"	V
hmm	test/fit.test.js	/^  const hmm = new HMM({$/;"	V
hmm	test/inference.test.js	/^  const hmm = new HMM({$/;"	V
hmm	test/log_likelihood.py	/^hmm = HMM(generator.num_states, generator.num_dims,$/;"	v
hmm	test/log_likelihood.test.js	/^  const hmm = new HMM({$/;"	V
hmm	test/maximization.py	/^hmm = HMM(generator.num_states, generator.num_dims,$/;"	v
hmm	test/maximization.test.js	/^  const hmm = new HMM({$/;"	V
hmm	test/sample.test.js	/^  const hmm = new HMM({$/;"	V
hmm	test/usage.test.js	/^  const hmm = new HMM({$/;"	V
hmmlearn_A	test/fit.py	/^hmmlearn_A = hmmlearn_model.transmat_[hmmlearn_reorder, :][:, hmmlearn_reorder]$/;"	v
hmmlearn_Sigma	test/fit.py	/^hmmlearn_Sigma = hmmlearn_model.covars_[hmmlearn_reorder, :, :]$/;"	v
hmmlearn_model	test/fit.py	/^hmmlearn_model = hmm.GaussianHMM($/;"	v
hmmlearn_model	test/inference.py	/^hmmlearn_model = hmm.GaussianHMM($/;"	v
hmmlearn_mu	test/fit.py	/^hmmlearn_mu = hmmlearn_model.means_[hmmlearn_reorder, :]$/;"	v
hmmlearn_pi	test/fit.py	/^hmmlearn_pi = hmmlearn_model.startprob_[hmmlearn_reorder]$/;"	v
hmmlearn_ref	test/inference.py	/^hmmlearn_ref = hmmlearn_model.predict(emissions_collaped, lengths)$/;"	v
hmmlearn_ref	test/inference.py	/^hmmlearn_ref = hmmlearn_ref.reshape(generator.num_obs, generator.num_time)$/;"	v
hmmlearn_reorder	test/fit.py	/^hmmlearn_reorder = np.argsort(hmmlearn_model.startprob_)$/;"	v
index	test/fit.test.js	/^      index: s,$/;"	P
index	test/initialize.test.js	/^      index: s,$/;"	P
index	test/sample.test.js	/^      index: s,$/;"	P
initialize	test/initialize.test.js	/^  const initialize = new Initialize({$/;"	V
iteration	lib/hmm.js	/^    let iteration = 0;$/;"	V
kmeans	test/initialize.py	/^kmeans = KMeans(n_clusters=generator.num_states,$/;"	v
kmeansCentroids	lib/initialize.js	/^    const kmeansCentroids = kmeansResult.centroids.map((o) => o.centroid);$/;"	F
lengths	test/fit.py	/^lengths = np.full([generator.num_obs], generator.num_time)$/;"	v
lengths	test/inference.py	/^lengths = np.full([generator.num_obs], generator.num_time)$/;"	v
loc	test/gaussian.py	/^    loc=tf.constant(generator.mu),$/;"	v
logLikelihood	test/log_likelihood.test.js	/^  const logLikelihood = tf.tidy(() => {$/;"	F
log_likelihood	test/log_likelihood.py	/^log_likelihood = hmm.posterior(np.transpose(emissions, [1, 0, 2]))$/;"	v
maxDiff	lib/hmm.js	/^    let maxDiff;$/;"	V
maxIterations	lib/initialize.js	/^      maxIterations: maxIterations,$/;"	P
maxIterations	test/initialize.test.js	/^    maxIterations: 100,$/;"	P
max_iter	test/expectation.py	/^max_iter = 100$/;"	v
max_iter	test/inference.py	/^max_iter = 100$/;"	v
max_iter	test/initialize.py	/^max_iter = 100$/;"	v
max_iter	test/maximization.py	/^max_iter = 100$/;"	v
max_iter	test/sample.py	/^max_iter = 100$/;"	v
mu	test/hmm.py	/^    def mu(self):$/;"	m	class:HMM
mu	test/initialize.py	/^mu = kmeans.cluster_centers_$/;"	v
mu	test/initialize.py	/^mu = mu[reorder_indices, :]$/;"	v
muSorted	test/fit.test.js	/^  const muSorted = [];$/;"	A
muSorted	test/initialize.test.js	/^  const muSorted = [];$/;"	A
muSorted	test/sample.test.js	/^  const muSorted = [];$/;"	A
n_components	test/fit.py	/^    n_components=generator.num_states,$/;"	v
n_components	test/inference.py	/^    n_components=generator.num_states,$/;"	v
newCholSigma	lib/gaussian.js	/^    const newCholSigma = new Float32Array($/;"	V
newDetSigma	lib/gaussian.js	/^    const newDetSigma = new Float32Array(this._states);$/;"	V
newSigmaInv	lib/gaussian.js	/^    const newSigmaInv = new Float32Array($/;"	V
nextSeed	lib/hmm.js	/^    function nextSeed () {$/;"	F
observation	lib/initialize.js	/^        const observation = [];$/;"	A
p0	test/hmm.py	/^    def p0(self):$/;"	m	class:HMM
pdf	test/gaussian.test.js	/^  const pdf = tf.tidy(() => {$/;"	F
pick	lib/gaussian.js	/^function pick (xTensor, indexTensor) {$/;"	F
posterior	test/hmm.py	/^    def posterior(self, data):$/;"	m	class:HMM
randomUniform	lib/hmm.js	/^function randomUniform (shape, dtype, seed) {$/;"	F
reorder	test/sample.py	/^reorder = np.argsort(generator.pi.ravel())$/;"	v
reorder_indices	test/initialize.py	/^reorder_indices = np.argsort(mu[:, 0])$/;"	v
run_viterbi	test/hmm.py	/^    def run_viterbi(self, data):$/;"	m	class:HMM
sample_list	lib/gaussian.js	/^    const sample_list = [];$/;"	A
seed	lib/initialize.js	/^      seed: seed$/;"	P
seed	test/initialize.test.js	/^    seed: 2$/;"	P
seed	test/sample.test.js	/^    seed: 1$/;"	P
seedCounter	lib/hmm.js	/^    let seedCounter = 0;$/;"	V
sigma	test/hmm.py	/^    def sigma(self):$/;"	m	class:HMM
softmax	test/tool_generate_data.py	/^def softmax(x):$/;"	f
sortInput	test/fit.test.js	/^  const sortInput = [];$/;"	A
sortInput	test/initialize.test.js	/^  const sortInput = [];$/;"	A
sortInput	test/sample.test.js	/^  const sortInput = [];$/;"	A
state_list	lib/hmm.js	/^    const state_list = [state_T]; \/\/ [(N, )]$/;"	A
states	test/inference.test.js	/^  const states = tf.tidy(() => {$/;"	F
states	test/initialize.py	/^states = kmeans.fit_predict(emissions_timeless)$/;"	v
states	test/initialize.test.js	/^    states: 2,$/;"	P
states	test/usage.test.js	/^      states: 0,$/;"	P
states	test/usage.test.js	/^      states: 1,$/;"	P
states	test/usage.test.js	/^    states: states,$/;"	P
states_list	lib/hmm.js	/^      const states_list = [states_0];$/;"	A
tensorflow_ref	test/inference.py	/^tensorflow_ref = tf_model.run_viterbi(np.transpose(emissions, [1, 0, 2]))$/;"	v
test	test/expectation.test.js	/^test('expectation step in EM-algorithm', async function (t) {$/;"	M
test	test/fit.test.js	/^test('fit uses EM-algorithm correctly', async function (t) {$/;"	M
test	test/gaussian.test.js	/^test('test Gaussian PDF calculations', async function (t) {$/;"	M
test	test/inference.test.js	/^test('inference using viterbi', async function (t) {$/;"	M
test	test/initialize.test.js	/^test('KMeans Initialization for alone observations', async function (t) {$/;"	M
test	test/initialize.test.js	/^test('KMeans Initialization for mu and Sigma', async function (t) {$/;"	M
test	test/initialize.test.js	/^test('KMeans Initialization for one state', async function (t) {$/;"	M
test	test/log_likelihood.test.js	/^test('log_likelihood by using forward algorithm', async function (t) {$/;"	M
test	test/maximization.test.js	/^test('maximization step in EM-algorithm', async function (t) {$/;"	M
test	test/sample.test.js	/^test('sampling from HMM distribution', async function (t) {$/;"	M
test	test/usage.test.js	/^test('usage documentation', async function (t) {$/;"	M
test	test/usage.test.js	/^test('usage mistakes in dimensions', async function (t) {$/;"	M
test	test/usage.test.js	/^test('usage mistakes in states', async function (t) {$/;"	M
tf	index.js	/^let tf;$/;"	V
tf_A	test/fit.py	/^tf_A = tf_model._tp[tf_reorder, :][:, tf_reorder]$/;"	v
tf_Sigma	test/fit.py	/^tf_Sigma = tf_model._sigma[tf_reorder, :, :]$/;"	v
tf_model	test/fit.py	/^tf_model = HMM(generator.num_states, generator.num_dims,$/;"	v
tf_model	test/inference.py	/^tf_model = HMM(generator.num_states, generator.num_dims,$/;"	v
tf_mu	test/fit.py	/^tf_mu = tf_model._mu[tf_reorder, :]$/;"	v
tf_pi	test/fit.py	/^tf_pi = tf_model._p0.ravel()[tf_reorder]$/;"	v
tf_reorder	test/fit.py	/^tf_reorder = np.argsort(tf_model._p0.ravel())$/;"	v
thisdir	test/expectation.py	/^thisdir = path.dirname(path.realpath(__file__))$/;"	v
thisdir	test/fit.py	/^thisdir = path.dirname(path.realpath(__file__))$/;"	v
thisdir	test/gaussian.py	/^thisdir = path.dirname(path.realpath(__file__))$/;"	v
thisdir	test/inference.py	/^thisdir = path.dirname(path.realpath(__file__))$/;"	v
thisdir	test/initialize.py	/^thisdir = path.dirname(path.realpath(__file__))$/;"	v
thisdir	test/log_likelihood.py	/^thisdir = path.dirname(path.realpath(__file__))$/;"	v
thisdir	test/maximization.py	/^thisdir = path.dirname(path.realpath(__file__))$/;"	v
thisdir	test/sample.py	/^thisdir = path.dirname(path.realpath(__file__))$/;"	v
timeless2d	lib/initialize.js	/^    const timeless2d = [];$/;"	A
tolerance	lib/hmm.js	/^      tolerance: maxDiff$/;"	P
tolerance	lib/initialize.js	/^      tolerance: tolerance,$/;"	P
tolerance	test/expectation.py	/^tolerance = 0.0001$/;"	v
tolerance	test/inference.py	/^tolerance = 0.0001$/;"	v
tolerance	test/initialize.py	/^tolerance = 0.0001$/;"	v
tolerance	test/maximization.py	/^tolerance = 0.0001$/;"	v
tolerance	test/sample.py	/^tolerance = 0.0001$/;"	v
tp	test/hmm.py	/^    def tp(self):$/;"	m	class:HMM
unscaledExponenentList	lib/gaussian.js	/^    const unscaledExponenentList = [];$/;"	A
w_list	lib/hmm.js	/^    const w_list = [w_0];$/;"	A
zerodiv	lib/hmm.js	/^function zerodiv (a, b) {$/;"	F
